# Docker MCP Server Integration Guide (Ops‑Copilot on Pi‑5)

This guide is a complete, copy-pasteable reference for wiring the **Docker MCP Server** into your Raspberry Pi 5 ARR stack assistant. It includes: a production-ready Docker Compose, tool registry & policy snippets, a FastAPI gateway adapter, and security knobs. It follows the pattern: **Gateway = policy/approvals/audit**; **MCP Server = execution**; **Only MCP touches docker.sock**.

## 0) Pi-Health Integration Checklist

To light up Docker telemetry and actions inside the Ops-Copilot UI:

1. Deploy the Docker MCP server (with optional socket proxy) using the compose file below.
2. Configure the AI gateway so it exposes the required tools (`docker_ps`, `compose_ps`, `compose_restart`, etc.).
3. Set the following environment variables for the Pi-Health Flask app (e.g. in `.env`, systemd unit, or compose file):

   ```bash
   DOCKER_MCP_BASE_URL=http://docker-mcp:8080
   DOCKER_MCP_COMPOSE_FILE=/opt/stack/docker-compose.yml   # optional but recommended
   MCP_READ_TIMEOUT=5.0                                    # optional override
   MCP_WRITE_TIMEOUT=30.0                                  # optional override
   ```

   If you omit `DOCKER_MCP_BASE_URL`, the app falls back to offline messaging and the UI behaves exactly as before.

4. Restart the Flask service (`docker compose restart pi-health` or systemd restart).

## 0.1) Verifying the UI Wiring

After the restart:

- Visit the Ops-Copilot page and ask “What is the Docker status?” – you should see a summary generated by the new `docker_status` tool. If the MCP server is unreachable, the reply includes a warning but the UI remains responsive.
- Ask “Sonarr queue looks stuck, can you restart it?” – the agent now proposes a suggestion labelled “Approve Restart”. Approving it fires `docker_actions.restart_container` through the MCP server (the request includes `approved=true`), so the real `compose_restart sonarr` runs. A success banner confirms the action.
- You can cross-check the REST API directly:

  ```bash
  curl -X POST http://localhost:8080/api/ops-copilot/chat \
       -H 'Content-Type: application/json' \
       -d '{"message":"check docker"}'
  ```

  The JSON payload includes `"tools":["docker_status", ...]` when the integration is active.

If you need to disable automation temporarily, just unset `DOCKER_MCP_BASE_URL` (or reboot without it). The suggestion flow stays intact but approvals will fall back to the legacy simulated response.

---

With the latest Pi-Health refactor you can surface Docker MCP telemetry directly inside Ops-Copilot by setting the environment variables listed above. When present, the app registers a `docker_status` tool that calls `docker_ps` and `compose_ps` via the gateway and injects the results into the AI prompt (with offline-safe error handling when the MCP is unreachable).

If approvals are enabled, the agent also loads a `docker_actions` tool that can execute `compose_restart`, `compose_start`, and `compose_stop` through the MCP server. Suggestions such as "Restart Sonarr" now route through that tool, so approving the action triggers the real compose command rather than a simulated response.

---

## 1) Docker Compose (with optional socket proxy)

```yaml
version: "3.9"

services:
  # (Optional, recommended) Limit Docker Engine API surface via a socket proxy
  docker-socket-proxy:
    image: tecnativa/docker-socket-proxy:edge
    container_name: docker-socket-proxy
    environment:
      - LOG_LEVEL=info
      # Enable only the endpoints Docker MCP needs (tighten as required)
      - EVENTS=1
      - PING=1
      - VERSION=1
      - CONTAINERS=1
      - IMAGES=1
      - NETWORKS=1
      - VOLUMES=1
      - PLUGINS=0
      - SECRETS=0
      - SWARM=0
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks: [ops_net]
    restart: unless-stopped
    read_only: true

  # Docker MCP Server — the only service allowed to control Docker/Compose
  docker-mcp:
    image: mcp/docker-mcp-server:latest
    container_name: mcp-docker
    user: "10001:10001"         # run non‑root if the image supports it
    environment:
      LOG_LEVEL: INFO
      COMPOSE_FILE: /opt/stack/docker-compose.yml
      DOCKER_HOST: tcp://docker-socket-proxy:2375
    volumes:
      # If skipping the proxy, remove DOCKER_HOST and mount the socket instead:
      # - /var/run/docker.sock:/var/run/docker.sock
      - /opt/stack:/opt/stack:ro
    networks: [ops_net]
    restart: unless-stopped
    read_only: true
    security_opt:
      - no-new-privileges:true
    depends_on:
      - docker-socket-proxy

  # AI Gateway — policy/approvals/audit (no docker.sock here)
  ai-gateway:
    image: yourorg/ai-gateway:dev
    container_name: ai-gateway
    env_file: ./.env.ops
    networks: [ops_net]
    restart: unless-stopped
    read_only: true
    security_opt:
      - no-new-privileges:true

networks:
  ops_net:
    driver: bridge
```

> **Why**: isolates Docker control in a single container; your gateway stays unprivileged. Socket proxy further reduces the engine API surface.

---

## 2) Tool Registration — `tool_registry.yaml`

```yaml
services:
  docker-mcp:
    base_url: http://docker-mcp:8080     # adjust per image docs
    transport: http                      # or sse/stdio if supported
    auth: none

tools:
  # --- READ‑ONLY ---
  docker_ps:
    mcp: { service: docker-mcp, fn: docker_ps }
    mutating: false
    summary: "List running containers (name, image, status)."

  compose_ps:
    mcp: { service: docker-mcp, fn: compose_ps }
    mutating: false
    summary: "Show Compose status for the bounded stack."

  compose_logs:
    mcp: { service: docker-mcp, fn: compose_logs }
    mutating: false
    summary: "Tail bounded lines of logs for one service."

  # --- MUTATING (approval required) ---
  compose_restart:
    mcp: { service: docker-mcp, fn: compose_restart }
    mutating: true
    approval: required
    cooldown: { seconds: 300, key_by: service }
    summary: "Restart a single service."

  compose_pull:
    mcp: { service: docker-mcp, fn: compose_pull }
    mutating: true
    approval: required
    roles: [admin]
    cooldown: { seconds: 3600 }
    summary: "Pull images for the stack."

  compose_up:
    mcp: { service: docker-mcp, fn: compose_up }
    mutating: true
    approval: required
    roles: [admin]
    cooldown: { seconds: 3600 }
    summary: "Recreate/update containers."
```

---

## 3) Gateway Policy — `policy.yaml`

```yaml
defaults:
  read_timeout_ms: 4000
  write_timeout_ms: 30000
  output_cap_bytes: 120000
  redact_patterns:
    - '(?i)apikey=\\w+'
    - '(?i)authorization:\\s*bearer\\s+[a-z0-9\\._-]+'

roles:
  admin:
    can_approve: ["*"]
  standard:
    can_approve: ["compose_restart"]
    deny_tools: ["compose_pull", "compose_up"]

cooldowns:
  compose_restart: { seconds: 300, key: "service" }
  compose_pull:    { seconds: 3600 }
  compose_up:      { seconds: 3600 }

schemas:
  docker_ps:
    type: object
    additionalProperties: false

  compose_ps:
    type: object
    properties:
      file: { type: string, const: "/opt/stack/docker-compose.yml" }
    required: [file]
    additionalProperties: false

  compose_logs:
    type: object
    properties:
      file:    { type: string, const: "/opt/stack/docker-compose.yml" }
      service: { type: string, pattern: "^[a-zA-Z0-9_-]{1,32}$" }
      tail:    { type: integer, minimum: 50, maximum: 500 }
    required: [file, service]
    additionalProperties: false

  compose_restart:
    type: object
    properties:
      file:    { type: string, const: "/opt/stack/docker-compose.yml" }
      service: { type: string, pattern: "^[a-zA-Z0-9_-]{1,32}$" }
    required: [file, service]
    additionalProperties: false

  compose_pull:
    type: object
    properties:
      file: { type: string, const: "/opt/stack/docker-compose.yml" }
    required: [file]
    additionalProperties: false

  compose_up:
    type: object
    properties:
      file: { type: string, const: "/opt/stack/docker-compose.yml" }
    required: [file]
    additionalProperties: false

guards:
  lock_compose_file: true
  trim_output: true
  redact_output: true
```

---

## 4) FastAPI Gateway Adapter (HTTP example)

```python
# gateway/adapters/docker_mcp.py
import os, httpx
from typing import Any, Dict

MCP_BASE = os.getenv("DOCKER_MCP_BASE", "http://docker-mcp:8080")
READ_TIMEOUT = float(os.getenv("READ_TIMEOUT", "4.5"))
WRITE_TIMEOUT = float(os.getenv("WRITE_TIMEOUT", "30"))

class ToolError(Exception): ...

class DockerMCPClient:
    def __init__(self, base=MCP_BASE):
        self.base = base

    def call(self, fn: str, args: Dict[str, Any], mutating: bool = False) -> Dict[str, Any]:
        url = f"{self.base}/tools/{fn}"
        timeout = WRITE_TIMEOUT if mutating else READ_TIMEOUT
        r = httpx.post(url, json=args, timeout=timeout)
        if r.status_code >= 400:
            raise ToolError(f"MCP {fn} -> {r.status_code}: {r.text[:300]}")
        return r.json()
```

```python
# gateway/main.py (essentials)
from fastapi import FastAPI, HTTPException
import yaml, jsonschema
from adapters.docker_mcp import DockerMCPClient, ToolError

app = FastAPI()
mcp = DockerMCPClient()

with open("policy.yaml") as f: POLICY = yaml.safe_load(f)
with open("tool_registry.yaml") as f: REG = yaml.safe_load(f)

def validate_schema(tool_name, args):
    schema = POLICY["schemas"].get(tool_name, {"type":"object","additionalProperties":True})
    jsonschema.validate(instance=args, schema=schema)

@app.post("/chat/tool")
def run_tool(payload: dict):
    tool_name = payload["tool"]
    args = payload.get("args", {})
    role = payload.get("role", "standard")

    if tool_name not in REG["tools"]:
        raise HTTPException(400, "Unknown tool")

    tool = REG["tools"][tool_name]
    mut = bool(tool.get("mutating"))

    # Validate args
    try:
        validate_schema(tool_name, args)
    except jsonschema.ValidationError as e:
        raise HTTPException(400, f"Bad args: {e.message}")

    # RBAC & approvals
    if mut and not payload.get("approved"):
        return {"need_approval": True, "tool": tool_name, "args": args, "rationale": tool.get("summary", "Mutating action")}

    if mut and tool.get("roles") and role not in tool["roles"]:
        raise HTTPException(403, "Not authorized")

    # Execute
    try:
        result = mcp.call(tool["mcp"]["fn"], args, mutating=mut)
    except ToolError as e:
        raise HTTPException(502, str(e))

    return {"ok": True, "tool": tool_name, "result": result}
```

---

## 5) Smoke Tests

1. **compose_ps** (no approval):

```json
{"tool":"compose_ps","args":{"file":"/opt/stack/docker-compose.yml"}}
```

2. **compose_logs** (no approval):

```json
{"tool":"compose_logs","args":{"file":"/opt/stack/docker-compose.yml","service":"sabnzbd","tail":150}}
```

3. **compose_restart** (approval flow):

* Call without `approved` → expect `need_approval`.
* Call again with `"approved":true` → executes and returns result.

---

## 6) Security Notes ("knobs")

* Only **docker-mcp** sees the Docker Engine (via socket proxy or direct socket).
* Run containers **read‑only** + `no-new-privileges:true` + non‑root UID/GID where possible.
* Enforce **JSON Schema** validation, RBAC, cooldowns, and output redaction in the gateway.
* Keep the compose file path **locked** (`/opt/stack/docker-compose.yml`).
* Expose the gateway only behind your reverse proxy & auth; do not publish MCP externally.

---

## 7) FAQ

**Can we add more MCPs (Radarr/Sonarr/Overseerr)?** Yes—repeat this pattern: register service, mark tools read vs mutating, add schemas, enforce approval.

**Local vs Remote LLM?** Keep LLM choice outside this guide. The gateway’s policy applies regardless of inference location.

**Can we skip the socket proxy?** You can, but the proxy significantly reduces the blast radius. If skipping, mount `/var/run/docker.sock` directly and ensure the MCP server image is trusted and pinned.
