"""
Samba share plugin.
Manages Samba share configuration.
"""
from __future__ import annotations

import json
import os
import re
import shutil
import subprocess
from typing import Generator

from storage_plugins.base import StoragePlugin, CommandResult, PluginStatus


SHARE_NAME_PATTERN = re.compile(r"^[a-zA-Z0-9._-]+$")


class SambaPlugin(StoragePlugin):
    """Samba share management plugin."""

    PLUGIN_ID = "samba"
    PLUGIN_NAME = "Samba"
    PLUGIN_VERSION = "1.0.0"
    PLUGIN_DESCRIPTION = "Share folders over SMB/CIFS"
    PLUGIN_CATEGORY = "share"
    PLUGIN_ENABLED_DEFAULT = False

    def __init__(self, config_dir: str):
        super().__init__(config_dir)
        self._schema = None
        self._smb_conf_path = os.environ.get("SAMBA_CONFIG_PATH", "/etc/samba/smb.conf")

    def get_schema(self) -> dict:
        if self._schema is None:
            self._schema = {
                "type": "object",
                "properties": {
                    "shares": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "name": {"type": "string", "description": "Share name (no spaces)"},
                                "path": {"type": "string", "description": "Absolute path to share"},
                                "comment": {"type": "string", "description": "Share description"},
                                "read_only": {"type": "boolean", "default": False},
                                "guest_ok": {"type": "boolean", "default": False},
                                "browseable": {"type": "boolean", "default": True},
                                "valid_users": {"type": "string", "description": "Comma-separated usernames"},
                                "enabled": {"type": "boolean", "default": True}
                            },
                            "required": ["name", "path"]
                        }
                    }
                }
            }
        return self._schema

    def get_config(self) -> dict:
        if os.path.exists(self.config_path):
            with open(self.config_path) as handle:
                return json.load(handle)
        return {"shares": []}

    def set_config(self, config: dict) -> CommandResult:
        try:
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            temp_path = f"{self.config_path}.tmp"
            with open(temp_path, "w") as handle:
                json.dump(config, handle, indent=2)
            os.replace(temp_path, self.config_path)
            return CommandResult(success=True, message="Configuration saved")
        except Exception as exc:
            return CommandResult(success=False, message="", error=str(exc))

    def validate_config(self, config: dict) -> list[str]:
        errors = []
        shares = config.get("shares", [])
        names = []

        for share in shares:
            name = share.get("name", "").strip()
            path = share.get("path", "").strip()

            if not name:
                errors.append("Share name is required")
            elif not SHARE_NAME_PATTERN.match(name):
                errors.append(f"Invalid share name: {name}")
            elif name in names:
                errors.append(f"Duplicate share name: {name}")
            names.append(name)

            if not path:
                errors.append(f"Share '{name}' requires a path")
            elif not path.startswith("/"):
                errors.append(f"Share path must be absolute: {path}")

        return errors

    def apply_config(self) -> CommandResult:
        config = self.get_config()
        errors = self.validate_config(config)
        if errors:
            return CommandResult(
                success=False,
                message="",
                error=f"Validation failed: {'; '.join(errors)}"
            )

        shares = config.get("shares", [])
        if not shares:
            return CommandResult(success=False, message="", error="No shares configured")

        config_path = os.path.join(self.config_dir, "samba.generated.conf")
        try:
            os.makedirs(self.config_dir, exist_ok=True)
            with open(config_path, "w") as handle:
                handle.write(self._generate_smb_config(shares))
            return CommandResult(
                success=True,
                message=f"Generated Samba config at {config_path}"
            )
        except Exception as exc:
            return CommandResult(success=False, message="", error=str(exc))

    def _generate_smb_config(self, shares: list[dict]) -> str:
        lines = [
            "# Generated by Pi-Health",
            "# Add these sections to /etc/samba/smb.conf (after [global] section)",
            "# Then restart: sudo systemctl restart smbd",
            ""
        ]
        for share in shares:
            # Skip disabled shares
            if not share.get("enabled", True):
                continue

            name = share.get("name", "")
            path = share.get("path", "")
            comment = share.get("comment", "").strip()
            read_only = "yes" if share.get("read_only", False) else "no"
            guest_ok = "yes" if share.get("guest_ok", False) else "no"
            browseable = "yes" if share.get("browseable", True) else "no"
            valid_users = share.get("valid_users", "").strip()

            lines.append(f"[{name}]")
            if comment:
                lines.append(f"   comment = {comment}")
            lines.extend([
                f"   path = {path}",
                f"   read only = {read_only}",
                f"   guest ok = {guest_ok}",
                f"   browseable = {browseable}"
            ])
            if valid_users:
                lines.append(f"   valid users = {valid_users}")
            lines.append("")

        return "\n".join(lines)

    def get_status(self) -> dict:
        if not self.is_installed():
            return {
                "status": PluginStatus.ERROR.value,
                "message": "Samba is not installed",
                "details": {},
                "service_running": False
            }

        config = self.get_config()
        shares = config.get("shares", [])
        service_running = self._is_service_running()

        if not shares:
            return {
                "status": PluginStatus.UNCONFIGURED.value,
                "message": "No shares configured",
                "details": {"shares": []},
                "service_running": service_running
            }

        enabled_shares = [s for s in shares if s.get("enabled", True)]
        disabled_shares = [s for s in shares if not s.get("enabled", True)]

        # Check if paths exist for enabled shares
        shares_with_status = []
        for share in shares:
            share_status = {
                **share,
                "path_exists": os.path.isdir(share.get("path", "")),
                "active": share.get("enabled", True) and service_running
            }
            shares_with_status.append(share_status)

        if not service_running:
            status = PluginStatus.DEGRADED.value
            message = f"{len(enabled_shares)} share(s) configured, service stopped"
        else:
            status = PluginStatus.HEALTHY.value
            message = f"{len(enabled_shares)} share(s) active"
            if disabled_shares:
                message += f", {len(disabled_shares)} disabled"

        return {
            "status": status,
            "message": message,
            "details": {"shares": shares_with_status},
            "service_running": service_running,
            "enabled_count": len(enabled_shares),
            "disabled_count": len(disabled_shares)
        }

    def import_existing_shares(self) -> CommandResult:
        """Import shares defined in smb.conf into plugin configuration."""
        shares = self._parse_smb_conf(self._smb_conf_path)
        if not shares:
            return CommandResult(success=True, message="No existing shares found", data={"imported": 0})

        config = self.get_config()
        existing = {s.get("name") for s in config.get("shares", [])}
        new_shares = [s for s in shares if s.get("name") not in existing]

        if not new_shares:
            return CommandResult(success=True, message="No new shares to import", data={"imported": 0})

        config["shares"] = config.get("shares", []) + new_shares
        result = self.set_config(config)
        if not result.success:
            return result
        return CommandResult(success=True, message="Imported existing shares", data={"imported": len(new_shares)})

    def _parse_smb_conf(self, path: str) -> list[dict]:
        """Parse smb.conf and return share configs."""
        if not os.path.exists(path):
            return []

        sections = {}
        current = None

        try:
            with open(path, "r") as handle:
                for raw_line in handle:
                    line = raw_line.strip()
                    if not line or line.startswith(("#", ";")):
                        continue
                    if line.startswith("[") and line.endswith("]"):
                        current = line[1:-1].strip()
                        sections[current] = {}
                        continue
                    if current and "=" in line:
                        key, value = line.split("=", 1)
                        key = key.strip().lower().replace(" ", "_")
                        value = value.strip()
                        sections[current][key] = value
        except Exception:
            return []

        shares = []
        skip_sections = {"global", "homes", "printers", "print$"}

        for name, data in sections.items():
            if name.lower() in skip_sections:
                continue
            path_value = data.get("path")
            if not path_value:
                continue

            def to_bool(value: str, default: bool) -> bool:
                if value is None:
                    return default
                return value.strip().lower() in {"yes", "true", "1"}

            read_only = to_bool(data.get("read_only") or data.get("readonly"), False)
            guest_ok = to_bool(data.get("guest_ok") or data.get("guest"), False)
            browseable = to_bool(data.get("browseable") or data.get("browsable"), True)
            enabled = to_bool(data.get("available"), True)
            comment = data.get("comment", "").strip()
            valid_users = data.get("valid_users", "").strip()

            shares.append({
                "name": name,
                "path": path_value,
                "comment": comment,
                "read_only": read_only,
                "guest_ok": guest_ok,
                "browseable": browseable,
                "valid_users": valid_users,
                "enabled": enabled
            })

        return shares

    def _is_service_running(self) -> bool:
        """Check if smbd service is running."""
        try:
            result = subprocess.run(
                ["systemctl", "is-active", "smbd"],
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except Exception:
            return False

    def get_commands(self) -> list[dict]:
        return [
            {
                "id": "restart",
                "name": "Restart Service",
                "description": "Restart the Samba service to apply changes",
                "confirm": True
            },
            {
                "id": "apply",
                "name": "Apply Config",
                "description": "Generate and show Samba configuration",
                "confirm": False
            }
        ]

    def run_command(self, command_id: str, params: dict = None) -> Generator[str, None, CommandResult]:
        if command_id == "restart":
            yield "Restarting Samba service...\n"
            try:
                result = subprocess.run(
                    ["systemctl", "restart", "smbd"],
                    capture_output=True,
                    timeout=30
                )
                if result.returncode == 0:
                    yield "Samba service restarted successfully.\n"
                    return CommandResult(success=True, message="Service restarted")
                else:
                    error = result.stderr.decode() if result.stderr else "Unknown error"
                    yield f"Failed to restart: {error}\n"
                    return CommandResult(success=False, message="", error=error)
            except subprocess.TimeoutExpired:
                yield "Timeout waiting for service restart.\n"
                return CommandResult(success=False, message="", error="Timeout")
            except Exception as e:
                yield f"Error: {e}\n"
                return CommandResult(success=False, message="", error=str(e))

        elif command_id == "apply":
            yield "Generating Samba configuration...\n\n"
            result = self.apply_config()
            if result.success:
                config = self.get_config()
                shares = config.get("shares", [])
                generated = self._generate_smb_config(shares)
                yield "Generated configuration:\n"
                yield "=" * 50 + "\n"
                yield generated
                yield "=" * 50 + "\n"
                yield f"\n{result.message}\n"
                return result
            else:
                yield f"Failed: {result.error}\n"
                return result

        yield f"Unknown command: {command_id}\n"
        return CommandResult(success=False, message="", error=f"Unknown command: {command_id}")

    def add_share(self, share: dict) -> CommandResult:
        """Add a new share."""
        config = self.get_config()
        shares = config.get("shares", [])

        # Check for duplicate name
        name = share.get("name", "").strip()
        if any(s.get("name") == name for s in shares):
            return CommandResult(success=False, message="", error=f"Share '{name}' already exists")

        # Validate
        test_config = {"shares": [share]}
        errors = self.validate_config(test_config)
        if errors:
            return CommandResult(success=False, message="", error="; ".join(errors))

        shares.append(share)
        config["shares"] = shares
        return self.set_config(config)

    def update_share(self, name: str, share: dict) -> CommandResult:
        """Update an existing share."""
        config = self.get_config()
        shares = config.get("shares", [])

        # Find and update
        found = False
        for i, s in enumerate(shares):
            if s.get("name") == name:
                # Preserve name if changing other fields
                share["name"] = name
                shares[i] = share
                found = True
                break

        if not found:
            return CommandResult(success=False, message="", error=f"Share '{name}' not found")

        # Validate
        errors = self.validate_config({"shares": shares})
        if errors:
            return CommandResult(success=False, message="", error="; ".join(errors))

        config["shares"] = shares
        return self.set_config(config)

    def remove_share(self, name: str) -> CommandResult:
        """Remove a share."""
        config = self.get_config()
        shares = config.get("shares", [])

        original_count = len(shares)
        shares = [s for s in shares if s.get("name") != name]

        if len(shares) == original_count:
            return CommandResult(success=False, message="", error=f"Share '{name}' not found")

        config["shares"] = shares
        return self.set_config(config)

    def toggle_share(self, name: str, enabled: bool) -> CommandResult:
        """Enable or disable a share."""
        config = self.get_config()
        shares = config.get("shares", [])

        for share in shares:
            if share.get("name") == name:
                share["enabled"] = enabled
                config["shares"] = shares
                return self.set_config(config)

        return CommandResult(success=False, message="", error=f"Share '{name}' not found")

    def is_installed(self) -> bool:
        return shutil.which("smbd") is not None

    def get_install_instructions(self) -> str:
        return "Install Samba: apt-get install samba / dnf install samba / pacman -S samba"
